<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Python学习笔记 | i207M&#39;s Fantastic Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://i207M.github.io/favicon.ico?v=1597134171231">
<link rel="stylesheet" href="https://i207M.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Learn from this
2020.7.31
容器初始化
list:[]
tuple:()
dict:{:}
set:{}

函数参数
位置参数
默认参数：默认参数必须指向不变对象！默认参数的值是在函数构建时被定义的。可以单独定义某个..." />
    <meta name="keywords" content="Python" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://i207M.github.io">
        <img src="https://i207M.github.io/images/avatar.png?v=1597134171231" class="site-logo">
        <h1 class="site-title">i207M&#39;s Fantastic Blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Lover - 世界都是我
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://i207M.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Python学习笔记</h2>
            <div class="post-date">2020-07-31</div>
            
            <div class="post-content" v-pre>
              <p>Learn from <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">this</a></p>
<h2 id="2020731">2020.7.31</h2>
<h3 id="容器初始化">容器初始化</h3>
<pre><code>list:[]
tuple:()
dict:{:}
set:{}
</code></pre>
<h3 id="函数参数">函数参数</h3>
<h4 id="位置参数">位置参数</h4>
<p>默认参数：默认参数必须指向不变对象！默认参数的值是在函数构建时被定义的。可以单独定义某个默认参数的值：</p>
<pre><code class="language-python">def enroll(a, b, c=1, d=2):
    print(a, b, c, d)

enroll(1, 2, d=5) # output: 1 2 1 5
</code></pre>
<h4 id="可变参数">可变参数</h4>
<p>可以传入一个<code>tuple</code>来解决</p>
<pre><code class="language-python">def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc((1,2,3)) # 此处要用双层括号
14
</code></pre>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*</code>的作用是将tuple的内容拆成一个个参数然后传入。</p>
<h4 id="关键字参数">关键字参数</h4>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个<strong>tuple</strong>。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<strong>dict</strong>。</p>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
            
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<h4 id="命名关键字参数">命名关键字参数</h4>
<p>限制关键字参数的名字。</p>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
    
&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>命名关键字参数必须传入参数名；命名关键字参数可以有缺省值。</p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了。</p>
<h4 id="参数组合">参数组合</h4>
<p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<h3 id="切片">切片</h3>
<p><code>s[L:R:D]</code>表示将s的<code>[L,R)</code>间距为D的片段切下来</p>
<p>特别的，<code>s[:2]</code> 表示切<code>s</code>的前两个元素；<code>s[-2:]</code>表示切<code>s</code>的后两个元素。</p>
<h3 id="迭代">迭代</h3>
<pre><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
for val in d.values():
    print(val)
for it in d.items():
    print(it) # tuple
</code></pre>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<pre><code class="language-python">for i, val in enumerate(['a', 'b', 'c']):
    print(i, val)
    
0 A
1 B
2 C

for x, y in [(1, 1), (2, 4), (3, 9)]:
	print(x, y)
</code></pre>
<h3 id="列表生成式">列表生成式</h3>
<p>感觉很好用！</p>
<pre><code class="language-python">L = list(range(1, 11))
L = [x * x for x in range(1, 11) if x % 2 == 0]
L = [m + n for m in ['a', 'b', 'c'] for n in ['x', 'y', 'z']]
</code></pre>
<h4 id="ifelsefor">if,else,for</h4>
<pre><code class="language-python">&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<h3 id="生成器">生成器</h3>
<p>简单的生成器相当于把list换成tuple。生成器只有next方式调出下一个，不能随机访问。可以用for遍历。</p>
<pre><code class="language-python">g = (x * x for x in range(10))
print(next(g))
for x in g:
    print(x, end=' ')

0
1 4 9 16 25 36 49 64 81

# 斐波那契数列生成器
def fib():
    a, b = 0, 1
    while True:
        yield b # ！！！
        a, b = b, a + b


f = fib()
for x in f:
    print(x)
    input()
</code></pre>
<p>变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p>generator函数也可以有返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中。</p>
<pre><code class="language-python">def triangles():
    A = []
    while True:
        for i in range(len(A) - 1, 0, -1):
            A[i] += A[i - 1]
        A.append(1)
        yield list(A)
</code></pre>
<p>以上是生成杨辉三角的生成器，值得注意的一点是，函数如果直接返回A，那么在函数里A的值改变的话，导出的A的值也会变。</p>
<p>改进版：</p>
<pre><code class="language-python">def triangles():
    A = [1]
    yield A
    while True:
        A = [1] + [A[i] + A[i + 1] for i in range(len(A) - 1)] + [1]
        yield A
</code></pre>
<p>为什么这样就可以返回A了呢，因为每经过一次赋值操作，A的地址都会重新分配。</p>
<h2 id="81">8.1</h2>
<h3 id="mapreduce">map&amp;reduce</h3>
<p>我们先看map。<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<pre><code class="language-python">def f(x):
	return x * x

&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用<code>reduce</code>实现：</p>
<pre><code class="language-python">from functools import reduce
def add(x, y):
	return x + y

&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<p>利用此方法可以方便的实现str转int：</p>
<pre><code class="language-python">def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))

# lambda

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

# str2float

def str2float(s):
    def merge(x, y):
        return x * 10 + y

    def str2num(s):
        return reduce(merge, map(int, s))

    p = 0
    while p &lt; len(s) and s[p] != '.':
        p += 1
    if p == len(s):
        return str2num(s)
    return str2num(s[:p]) + str2num(s[p + 1:]) * 0.1**(len(s) - p - 1)

# 写的还是太长，等学会lambda和str的函数再简化吧
</code></pre>
<h3 id="filter">filter</h3>
<p>接收一个函数和一个序列，返回一个Iterator，只保留True的元素。</p>
<pre><code class="language-python">def is_palindrome(n):
    s = str(n)
    return s == s[::-1]
</code></pre>
<p>筛回文好简单...</p>
<h3 id="sorted">sorted</h3>
<p>我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序，相当于把所有元素都应用key之后再排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h3 id="闭包">闭包</h3>
<p>大杀器。类似于C++中的lamba.</p>
<p>返回一个函数，这个函数会同时包含它所需要的变量。</p>
<p>需要注意的问题：</p>
<p>返回的函数没有立即执行，而是等到调用才执行。 <strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<h4 id="创建计数器">创建计数器</h4>
<p>这道题很妙啊。</p>
<pre><code class="language-python">def createCounter():
    n = 0

    def counter():
        nonlocal n # 声明这是外层的变量
        n += 1
        return n

    return counter

def createCounter():
    n = [0]

    def counter():
        n[0] += 1 # 为什么这里可以修改？因为n这个变量实际上是指向一片内存地址！
        return n[0]

    return counter
</code></pre>
<h3 id="匿名函数">匿名函数</h3>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数，冒号后面的表达式是返回值。</p>
<h3 id="装饰器">装饰器</h3>
<p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p>
<pre><code class="language-python">&gt;&gt;&gt; f=now
&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>假设我们要在<code>now</code>函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”。</p>
<p>本质上，decorator就是一个返回函数的高阶函数，可以定义如下：</p>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>我们可以借助Python的@语法，把decorator置于函数的定义处：</p>
<pre><code class="language-python">@log
def now():
    pass
</code></pre>
<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志。</p>
<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<pre><code class="language-python">now = log(now)
</code></pre>
<p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。</p>
<p>decorater本身也可以传入参数：</p>
<p>比如，要自定义log的文本：</p>
<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code class="language-python">@log('execute')
def now():
    pass
</code></pre>
<p>但是，这样装饰之后的 函数，它的<code>__name__</code>已经不是原来的函数了。Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code class="language-python">import functools

def log(func):
    @functools.wraps(func) # !!!
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p>
<pre><code class="language-python">def metric(fn):
    @functools.wraps(fn)
    def warpper(*args, **kw):
        s = time.time()
        r = fn(*args, **kw)
        e = time.time()
        print('%s run in %.2f ms' % (fn.__name__, e - s))
        return r

    return warpper
</code></pre>
<h3 id="偏函数">偏函数</h3>
<pre><code class="language-python">int2 = functools.partial(int, base=2)
</code></pre>
<p>固定函数的参数。</p>
<h2 id="82">8.2</h2>
<h3 id="模块">模块</h3>
<pre><code class="language-python">'A module'  # 任何模块代码的第一个字符串都被视为模块的文档注释，可以用__doc__调用

__author__ = 'i207M' # 标准模板

import sys


def run():
    print(sys.argv) # sys模块定义了sys.argv，本质是list，储存了调用这个py文件的参数


if __name__ == '__main__': # 当且仅当它是独立运行而不是被import进别的py时，此判断为True
    run()
</code></pre>
<p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；</p>
<p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael']</code>。</p>
<h4 id="作用域">作用域</h4>
<p>正常函数的命名是公开的。</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，如<code>__author__</code>，<code>__name__</code>，<code>__doc__</code>。</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的，不应该被直接引用。不应该，不是不能。</p>
<h3 id="面向对象oop">面向对象OOP</h3>
<p><code>__init__</code>方法相当于构造函数。注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身。</p>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，这样在外部就真的无法访问。但是在外部定义class的<code>__</code>开头的变量是可以被访问的。</p>
<p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>这就是著名的**“开闭”原则**：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p><em>“鸭子类型”：它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</em></p>
<p><code>print</code>一个class，实质会调用<code>__str__()</code>函数，打印此函数的返回值。直接在控制台输入变量，打印的实例是调用<code>__repr__()</code>。</p>
<h4 id="定制类">定制类</h4>
<p>定义了<code>__iter__(),__next__()</code>，就可以被用于<code>for ... in</code>循环：</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self._a, self._b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        self._a, self._b = self._b, self._a + self._b
        if self._a &gt; 1000:
            raise StopIteration()
        return self._a
</code></pre>
<p>实现<code>__getitem__()</code>方法，可以按下标访问任意一项。</p>
<p>当调用不存在的属性时，Python解释器会试图调用<code>__getattr__(self, 'name')</code>来尝试获得属性。</p>
<p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p>
<pre><code class="language-python">class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
</code></pre>
<p>试试：</p>
<pre><code class="language-python">&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'
</code></pre>
<p>Niubi</p>
<p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。</p>
<pre><code class="language-python">class Chain(object):
    def __init__(self, path=''):
        self.path = path

    def __getattr__(self, attr):
        return Chain(&quot;%s/%s&quot; % (self.path, attr))

    def __call__(self, *args):
        _self = self
        for i in args:
            _self = Chain(&quot;%s/%s&quot; % (_self.path, i))
        return _self

    def __str__(self):
        return self.path

    __repr__ = __str__


&gt;&gt;&gt; print(Chain().a(&quot;hello&quot;, &quot;good&quot;).b)
/a/hello/good/b
</code></pre>
<h4 id="type">type</h4>
<p>type返回类型，是严格的类型，同一个父类下的子类互不相同。</p>
<p>使用<code>instance()</code>函数可以判断继承类型。</p>
<h3 id="类和实例">类和实例</h3>
<p>可以定义类属性和实例属性，实例属性优先于类属性。</p>
<p>实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态。</p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code class="language-python">class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 方便！
</code></pre>
<h4 id="给实例绑定一个方法">给实例绑定一个方法</h4>
<pre><code class="language-python">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法，只有s能调用

&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score # 所有实例都可以调用
</code></pre>
<p>Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>对子类不起作用，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<p>但是当父类无<code>__slots__</code>，而子类有，则无效。</p>
<h3 id="property">@property</h3>
<p>实现类的时候，我们常常需要提供各种借口，但是为每个接口都写一个函数有些麻烦，使用也不方便，我们可以用<code>@property</code>，使得可以直接调用变量，用等号修改，且进行范围检查。</p>
<pre><code class="language-python">class Student(object):
    @property
    def score(self):
        return self.__score

    @score.setter
    def score(self, val):
        if 0 &lt;= val and val &lt;= 100:
            self.__score = val
        else:
            raise ValueError('Score Error')
</code></pre>
<p><code>@property</code>后定义的函数作为此名变量的getter方法；此时，<code>@property</code>本身又创造了另一个修饰器<code>@score.setter</code>，实现setter方法，如果没有setter方法，则变量为只读。</p>
<h3 id="多重继承">多重继承</h3>
<p>RT：</p>
<pre><code class="language-python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>如果方法重复怎么办？优先保留顺序靠前的。</p>
<h3 id="枚举类">枚举类</h3>
<p>继承自Enum。<code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p>
<h3 id="元类">元类</h3>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072">太 妙 了！豁然开朗！</a>（用到时再复习吧）</p>
<p><strong><a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html">super()</a></strong></p>
<h2 id="202083">2020.8.3</h2>
<h3 id="错误处理">错误处理</h3>
<p>感觉这个挺重要的。</p>
<pre><code class="language-python">try:
    pass
expect ... as ...:
    pass
</code></pre>
<p>出错时，直接跳转到except语句块。错误也是class，继承自<code>BaseException</code>。</p>
<p>如果错误没有被捕获，会一直往上抛，最后被Python解释器捕获，打印错误信息并退出。这就是<strong>调用栈</strong>。</p>
<p>Python内置的<code>logging</code>模块可以记录错误信息。</p>
<pre><code class="language-python">try:
    main()
except Exception as e:
    logging.exception(e)
</code></pre>
<p>这样程序可以继续运行，并且错误被记录。</p>
<p><code>except</code>语句内可以继续<code>raise</code>，抛给上一层。</p>
<h3 id="调试">调试</h3>
<p><code>assert</code>+VS Code</p>
<h3 id="文件读写">文件读写</h3>
<p>使用<code>f=open(file,'r'/'rb'/'w'/'a'[,encoding=])</code>，退出程序前记得<code>f.close()</code>。</p>
<p>方便的方法是使用<code>with</code>语句：</p>
<pre><code class="language-python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>建议使用<code>with</code>语句，以防忘记<code>close</code>，如果不能直接使用<code>with</code>语句，可以</p>
<h4 id="stringiobytesio">StringIO&amp;BytesIO</h4>
<p>在内存中读写str。像文件一样写入即可。<code>from io import StringIO</code></p>
<h4 id="os模块">os模块</h4>
<pre><code class="language-python">os.path.abspath('')
os.path.join('','') # 拼接路径
os.mkdir('')
os.rmdir('')
os.path.split('') # 返回list，将路径拆为两部分，后一部分是文件（夹）名
os.path.splittext('') # 返回文件扩展名
os.rename('','')
os.remove('')
os.listdir('') # 文件夹+文件
os.path.isdir('')
</code></pre>
<p><code>copyfile()</code>在<code>shutil</code>模块。</p>
<p><code>os.walk('')</code>返回的是一个三元组(root,dirs,files)。</p>
<ul>
<li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li>
<li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li>
<li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li>
</ul>
<pre><code class="language-python">for root, dirs, files in os.walk('.'):
    for name in files:
        print(os.path.join(root, name))

def mywalk(path):
    for name in os.listdir(path):
        ful = os.path.join(path, name)
        if os.path.isdir(name):
            try:
                mywalk(ful)
            except Exception as e:
                print(e)
        else:
            print(ful)
</code></pre>
<h3 id="序列化">序列化</h3>
<p>先鸽了。大致用途是将Python对象变成JSON。</p>
<h3 id="常用内建模块">常用内建模块</h3>
<pre><code class="language-python">from datetime import datetime

now = datetime.now() # 是一个class
t = now.timestamp() # 返回从1970年开始的秒数，浮点数
datetime.fromtimestamp(t) # 本地时区

day = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S') # 注意，转换后无时区信息
print(now.strftime('%a, %b %d %H:%M'))

def to_timestamp(dt_str, tz_str):
    tim = datetime.strptime(dt_str, '%Y-%m-%d %H:%M:%S')
    sq = re.findall(r'UTC(.*):00', tz_str)
    sq = int(sq[0])
    tim = tim.replace(tzinfo=timezone(timedelta(hours=sq)))
    return tim.timestamp()


t1 = to_timestamp('2015-6-1 08:10:30', 'UTC+7:00')
assert t1 == 1433121030.0
</code></pre>
<p>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h4 id="collections">collections</h4>
<p><code>namedtuple('NAME',['args'])</code></p>
<p><code>deque</code></p>
<p><code>defaultdict(function)</code>有默认值的<code>dict</code></p>
<h4 id="hashlib">hashlib</h4>
<pre><code class="language-python">import hashlib

md5 = hashlib.md5('original')
md5.update('Hello, '.encode('utf-8')) # 必须encode
md5.update('World'.encode('utf-8'))
print(md5.hexdigest())
# 同理可用sha1

import hmac
h=hmac.new(key, message, digestmode='MD5')
</code></pre>
<h4 id="itertools">itertools</h4>
<pre><code class="language-python">&gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
</code></pre>
<h2 id="84">8.4</h2>
<p>昨天属实有点摸鱼。今天把<code>urllib</code>这些事学了。</p>
<p>强基快要出结果了.jpg</p>
<p>学这个之前要先把JSON学了。</p>
<h3 id="json">JSON</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/08/04/HPh7R5XcgVzAMpn.png" alt="image-20200804083520132" loading="lazy"></figure>
<p>使用内置的<code>json</code>模块。</p>
<p><code>json.dumps(arg)</code>返回<code>str</code>，内容是标准的JSON。<code>dump(arg,file)</code>可以直接把结果写入文件流中。</p>
<p>反序列化使用<code>loads()/load()</code>。</p>
<p>如果是自定义的Class如何序列化？</p>
<p>可选参数<code>default</code>把任意一个对象变成一个可序列为JSON的对象。</p>
<pre><code class="language-python">def student2dict(std):
    return dict(
        name=std.name,
        age=std.age,
        score=std.score,
    )
</code></pre>
<p>有一个Trick方法：</p>
<pre><code class="language-python">json.dumps(t, default=lambda obj: obj.__dict__)
</code></pre>
<p>同理可以反序列化。</p>
<h3 id="urllib">urllib</h3>
<p>基本上实现GET和POST就够了。</p>
<h4 id="get">Get</h4>
<p><code>request</code>模块可以发送一个GET到指定的页面。</p>
<pre><code class="language-python">from urllib import request

with request.urlopen('https://yesno.wtf/api') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    data = data.decode('utf-8')
    print('Data:', data)
    js = json.loads(data)
    print(js)
    for it in js.items():
        print('%s: %s' % it)
</code></pre>
<p>挺简单易懂的。如果使用<code>f.getheader(str)</code>，可以返回某个header.</p>
<p><code>urlopen</code>函数除了直接传入网址，还可以传入<code>Request</code>类，实现自定义header，从而自定义UA等功能。</p>
<pre><code class="language-python">req = request.Request('http://www.douban.com/')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
</code></pre>
<h4 id="post">POST</h4>
<p>只需要把参数以bytes形式传入。可以借助<code>parse.urlencode</code>.</p>
<p>模拟微博登录：</p>
<pre><code class="language-python">from urllib import request, parse

print('Login Weibo...')
email = input('Email:')
pwd = input('Password:')
login_data = parse.urlencode(
    [
        ('username', email), ('password', pwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''),
        ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')
    ]
)

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for it in f.getheaders():
        print('%s: %s' % it)
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<h4 id="handler">Handler</h4>
<p>默认使用的代理是系统设置的，如果要更改，感觉urllib提供的实现很复杂，之后学习requsets或urllib2.</p>
<pre><code class="language-python"># urllib
proxy_handler = request.ProxyHandler({'http': 'http://127.0.0.1:2334', 'https': 'https://127.0.0.1:2334'})
proxy_auth_handler = request.ProxyBasicAuthHandler()
opener = request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('https://www.google.com/') as f:
    print('Status:', f.status, f.reason) # 200 OK
</code></pre>
<h2 id="810">8.10</h2>
<p><code>HTMLParser</code>：先鸽了。</p>
<h3 id="pil">PIL</h3>
<p>Python Imaging Library</p>
<pre><code class="language-python">from PIL import Image

im = Image.open('t.png')
w, h = im.size
im.thumbnail((w // 4, h // 4)) # 缩放
im.save('tt.jpg', 'jpeg')

im2 = im.filter(ImageFilter.BLUR) # 模糊
</code></pre>
<h4 id="生成验证码">生成验证码</h4>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random


def rndChar():
    return chr(random.randint(65, 90))


def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))


def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))


h = 60
w = h * 4

im = Image.new('RGB', (w, h), (255, 255, 255)) # 创建。Modes除了RGB还有'1'(1-bit,black and white),'L'(8-bit,black and white)

font = ImageFont.truetype('arial.ttf', 36) # 字体
draw = ImageDraw.Draw(im)
for x in range(w):
    for y in range(h):
        draw.point((x, y), fill=rndColor()) # 画背景

for t in range(4):
    draw.text((60 * t + 10, random.randint(1, 27)), rndChar(), font=font, fill=rndColor2()) # 写字母

im = im.filter(ImageFilter.BLUR)
im.save('code.jpg', 'jpeg')
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/08/10/24dZyRCYlbG1POB.jpg" alt="" loading="lazy"></figure>
<p>加强过后（加入了字符旋转）：</p>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random


def rndChar():
    return chr(random.randint(65, 90))


def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))


def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))


h = 60
w = h * 4

im = Image.new('RGB', (w, h), (255, 255, 255))

font = ImageFont.truetype('arial.ttf', 40)
dr = ImageDraw.Draw(im)
for x in range(w):
    for y in range(h):
        dr.point((x, y), fill=rndColor())
for t in range(4):
    text_layer = Image.new('RGBA', (40, 40)) # 注意是RGBA，A表示透明度
    text_draw = ImageDraw.Draw(text_layer)
    text_draw.text((0, 0), rndChar(), font=font, fill=(*rndColor2(), 255))
    text_layer = text_layer.rotate(random.randint(0, 360)) # 旋转
    im.paste(text_layer, (60 * t, random.randint(0, 20)), text_layer) # 粘贴

im = im.filter(ImageFilter.BLUR)
im.save('code.jpg', 'jpeg')
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/08/10/o1c93qCtTzPfi4g.jpg" alt="" loading="lazy"></figure>
<p>爽！PythonNB！</p>
<h3 id="requests">requests</h3>
<p>比urllib更强悍。</p>
<pre><code class="language-python">r = requests.get('URL')
r.status_code
r.text # 内容（自动检测编码）
r.content # bytes对象
</code></pre>
<p>对于带参数的URL，传入dict作为<code>params</code>参数。</p>
<p><code>headers</code>参数可以传入dict。</p>
<p><em>另外一提，使用http访问百度搜索不需要UA，使用https就必须UA。</em></p>
<p>要发送POST，只需要把方法变成<code>post()</code>，然后用<code>data</code>参数作为POST请求的数据。默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON，可以传入json参数。</p>
<p><a href="https://blog.csdn.net/xiao__jia__jia/article/details/79357274">四种常见的 POST 提交数据方式</a></p>
<p><em>重写百度翻译爬虫ing</em></p>
<p>上传文件可以使用<code>files</code>参数，读取文件时，必须使用<code>'rb'</code>模式，这样获取的<code>bytes</code>长度才是文件的长度。</p>
<pre><code class="language-python">upfile = {'file': open('name','rb')}
r = requests.post(url, files=upfile)
</code></pre>
<p>requests对Cookie做了处理，使我们不必解析Cookie就可以直接获取指定的Cookie。</p>
<pre><code class="language-python">print(r.cookies['token'])
</code></pre>
<p>要传入cookie，只需将dict传入<code>cookies</code>参数。</p>
<p>要指定超时，传入以秒为单位的timeout参数。</p>
<h3 id="chardet">chardet</h3>
<p>对于未知编码的<code>bytes</code>，转换成<code>str</code>需要“猜测”编码，<code>chardet</code>这个第三方库通过收集编码的特征字符，有很大概率猜对。</p>
<pre><code class="language-python">&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('gbk')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'}
</code></pre>
<p><code>confidence</code>是概率。</p>
<h3 id="psutil">psutil</h3>
<p>psutil = process and system utilities</p>
<p>获取系统信息，先鸽了。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://i207M.github.io/tag/MbRpYoDiZ/" class="tag">
                    Python
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://i207M.github.io/post/iot-kai-fa-ru-men/">
                  <h3 class="post-title">
                    物联网开发笔记
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
