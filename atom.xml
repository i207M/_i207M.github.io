<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://i207M.github.io</id>
    <title>i207M&apos;s Fantastic Blog</title>
    <updated>2020-08-02T02:44:05.234Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://i207M.github.io"/>
    <link rel="self" href="https://i207M.github.io/atom.xml"/>
    <subtitle>Lover - 世界都是我</subtitle>
    <logo>https://i207M.github.io/images/avatar.png</logo>
    <icon>https://i207M.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, i207M&apos;s Fantastic Blog</rights>
    <entry>
        <title type="html"><![CDATA[Python学习笔记]]></title>
        <id>https://i207M.github.io/post/python-xue-xi-bi-ji/</id>
        <link href="https://i207M.github.io/post/python-xue-xi-bi-ji/">
        </link>
        <updated>2020-07-31T09:25:07.000Z</updated>
        <content type="html"><![CDATA[<p>Learn from <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">this</a></p>
<h2 id="2020731">2020.7.31</h2>
<h3 id="容器初始化">容器初始化</h3>
<pre><code>list:[]
tuple:()
dict:{:}
set:{}
</code></pre>
<h3 id="函数参数">函数参数</h3>
<p>位置参数<br>
默认参数：默认参数必须指向不变对象！默认参数的值是在函数构建时被定义的。可以单独定义某个默认参数的值：</p>
<pre><code class="language-python">def enroll(a, b, c=1, d=2):
    print(a, b, c, d)

enroll(1, 2, d=5) # output: 1 2 1 5
</code></pre>
<h3 id="可变参数">可变参数</h3>
<p>可以传入一个<code>tuple</code>来解决</p>
<pre><code class="language-python">def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc((1,2,3)) # 此处要用双层括号
14
</code></pre>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*</code>的作用是将tuple的内容拆成一个个参数然后传入。</p>
<h3 id="关键字参数">关键字参数</h3>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个<strong>tuple</strong>。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<strong>dict</strong>。</p>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
            
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<h3 id="命名关键字参数">命名关键字参数</h3>
<p>限制关键字参数的名字。</p>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
    
&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>命名关键字参数必须传入参数名；命名关键字参数可以有缺省值。</p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了。</p>
<h3 id="参数组合">参数组合</h3>
<p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<h3 id="切片">切片</h3>
<p><code>s[L:R:D]</code>表示将s的<code>[L,R)</code>间距为D的片段切下来</p>
<p>特别的，<code>s[:2]</code> 表示切<code>s</code>的前两个元素；<code>s[-2:]</code>表示切<code>s</code>的后两个元素。</p>
<h3 id="迭代">迭代</h3>
<pre><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
for val in d.values():
    print(val)
for it in d.items():
    print(it)
</code></pre>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<pre><code class="language-python">for i, val in enumerate(['a', 'b', 'c']):
    print(i, val)
    
0 A
1 B
2 C

for x, y in [(1, 1), (2, 4), (3, 9)]:
	print(x, y)
</code></pre>
<h3 id="列表生成式">列表生成式</h3>
<p>感觉很好用！</p>
<pre><code class="language-python">L = list(range(1, 11))
L = [x * x for x in range(1, 11) if x % 2 == 0]
L = [m + n for m in ['a', 'b', 'c'] for n in ['x', 'y', 'z']]
</code></pre>
<h4 id="ifelsefor">if,else,for</h4>
<pre><code class="language-python">&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<h3 id="生成器">生成器</h3>
<p>简单的生成器相当于把list换成tuple。生成器只有next方式调出下一个，不能随机访问。可以用for遍历。</p>
<pre><code class="language-python">g = (x * x for x in range(10))
print(next(g))
for x in g:
    print(x, end=' ')

0
1 4 9 16 25 36 49 64 81

# 斐波那契数列生成器
def fib():
    a, b = 0, 1
    while True:
        yield b # ！！！
        a, b = b, a + b


f = fib()
for x in f:
    print(x)
    input()
</code></pre>
<p>变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p>generator函数也可以有返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中。</p>
<pre><code class="language-python">def triangles():
    A = []
    while True:
        for i in range(len(A) - 1, 0, -1):
            A[i] += A[i - 1]
        A.append(1)
        yield list(A)
</code></pre>
<p>以上是生成杨辉三角的生成器，值得注意的一点是，函数如果直接返回A，那么在函数里A的值改变的话，导出的A的值也会变。</p>
<p>改进版：</p>
<pre><code class="language-python">def triangles():
    A = [1]
    yield A
    while True:
        A = [1] + [A[i] + A[i + 1] for i in range(len(A) - 1)] + [1]
        yield A
</code></pre>
<p>为什么这样就可以返回A了呢，因为每经过一次赋值操作，A的地址都会重新分配。</p>
<h2 id="81">8.1</h2>
<h3 id="mapreduce">map&amp;reduce</h3>
<p>我们先看map。<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<pre><code class="language-python">def f(x):
	return x * x

&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用<code>reduce</code>实现：</p>
<pre><code class="language-python">from functools import reduce
def add(x, y):
	return x + y

&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<p>利用此方法可以方便的实现str转int：</p>
<pre><code class="language-python">def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))

# lambda

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

# str2float

def str2float(s):
    def merge(x, y):
        return x * 10 + y

    def str2num(s):
        return reduce(merge, map(int, s))

    p = 0
    while p &lt; len(s) and s[p] != '.':
        p += 1
    if p == len(s):
        return str2num(s)
    return str2num(s[:p]) + str2num(s[p + 1:]) * 0.1**(len(s) - p - 1)

# 写的还是太长，等学会lambda和str的函数再简化吧
</code></pre>
<h3 id="filter">filter</h3>
<p>接收一个函数和一个序列，返回一个Iterator，只保留True的元素。</p>
<pre><code class="language-python">def is_palindrome(n):
    s = str(n)
    return s == s[::-1]
</code></pre>
<p>筛回文好简单...</p>
<h3 id="sorted">sorted</h3>
<p>我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h3 id="闭包">闭包</h3>
<p>大杀器。类似于C++中的lamba.</p>
<p>返回一个函数，这个函数会同时包含它所需要的变量。</p>
<p>需要注意的问题：</p>
<p>返回的函数没有立即执行，而是等到调用才执行。 <strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<h4 id="创建计数器">创建计数器</h4>
<p>这道题很妙啊。</p>
<pre><code class="language-python">def createCounter():
    n = 0

    def counter():
        nonlocal n # 声明这是外层的变量
        n += 1
        return n

    return counter

def createCounter():
    n = [0]

    def counter():
        n[0] += 1 # 为什么这里可以修改？因为n这个变量实际上是指向一片内存地址！
        return n[0]

    return counter
</code></pre>
<h3 id="匿名函数">匿名函数</h3>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数，冒号后面的表达式是返回值。</p>
<h3 id="装饰器">装饰器</h3>
<p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p>
<pre><code class="language-python">&gt;&gt;&gt; f=now
&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>假设我们要在<code>now</code>函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”。</p>
<p>本质上，decorator就是一个返回函数的高阶函数，可以定义如下：</p>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>我们可以借助Python的@语法，把decorator置于函数的定义处：</p>
<pre><code class="language-python">@log
def now():
    pass
</code></pre>
<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志。</p>
<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<pre><code class="language-python">now = log(now)
</code></pre>
<p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。</p>
<p>decorater本身也可以传入参数：</p>
<p>比如，要自定义log的文本：</p>
<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code class="language-python">@log('execute')
def now():
    pass
</code></pre>
<p>但是，这样装饰之后的 函数，它的<code>__name__</code>已经不是原来的函数了。Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code class="language-python">import functools

def log(func):
    @functools.wraps(func) # !!!
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p>
<pre><code class="language-python">def metric(fn):
    @functools.wraps(fn)
    def warpper(*args, **kw):
        s = time.time()
        r = fn(*args, **kw)
        e = time.time()
        print('%s run in %.2f ms' % (fn.__name__, e - s))
        return r

    return warpper
</code></pre>
<h3 id="偏函数">偏函数</h3>
<pre><code class="language-python">int2 = functools.partial(int, base=2)
</code></pre>
<p>固定函数的参数。</p>
<h2 id="82">8.2</h2>
<h3 id="模块">模块</h3>
<pre><code class="language-python">'A module'  # 任何模块代码的第一个字符串都被视为模块的文档注释，可以用__doc__调用

__author__ = 'i207M' # 标准模板

import sys


def run():
    print(sys.argv) # sys模块定义了sys.argv，本质是list，储存了调用这个py文件的参数


if __name__ == '__main__': # 当且仅当它是独立运行而不是被import进别的py时，此判断为True
    run()
</code></pre>
<p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；</p>
<p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael']</code>。</p>
<h4 id="作用域">作用域</h4>
<p>正常函数的命名是公开的。</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，如<code>__author__</code>，<code>__name__</code>，<code>__doc__</code>。</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的，不应该被直接引用。不应该，不是不能。</p>
<h3 id="面向对象oop">面向对象OOP</h3>
<p><code>__init__</code>方法相当于构造函数。注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身。</p>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，这样在外部就真的无法访问。但是在外部定义class的<code>__</code>开头的变量是可以被访问的。</p>
<p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>这就是著名的**“开闭”原则**：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p><em>“鸭子类型”：它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</em></p>
<h4 id="type">type</h4>
<p>type返回类型，是严格的类型，同一个父类下的子类互不相同。</p>
<p>使用<code>instance()</code>函数可以判断继承类型。</p>
<h3 id="类和实例">类和实例</h3>
<p>实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态。</p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code class="language-python">class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 方便！
</code></pre>
<h4 id="给实例绑定一个方法">给实例绑定一个方法</h4>
<pre><code class="language-python">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法，只有s能调用

&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score # 所有实例都可以调用
</code></pre>
<p>Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>对子类不起作用，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[物联网开发笔记]]></title>
        <id>https://i207M.github.io/post/iot-kai-fa-ru-men/</id>
        <link href="https://i207M.github.io/post/iot-kai-fa-ru-men/">
        </link>
        <updated>2020-07-30T14:28:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="2020730">2020.7.30</h2>
<p>THU面试结束，开始心仪已久的IoT开发尝试。首先使用的是ESP-8266系列的ESP-01芯片。<br>
上午主要把驱动和Arduino IDE鼓捣好了，感谢我爸事先的开荒。<br>
后来花了好长时间尝试点灯（就是运行Blink实例），怎么样都不能成功，后来发现ESP-01S才有灯，我手里这个没有...<br>
后来又花了好长时间尝试Advanced Webserver这个示例，同样是一直无解，甚至都以为自己不小心刷坏了WiFi模块...直到把这个问题给小黄鸭（家父）说了一下，然后猛然意识到，SSID和password应该填自己家已有的WiFi...睿智了睿智了，然后就成功的连上了WiFi并作为服务器连接到了我的小板子。<br>
晚上开始鼓捣PlatformIO，但是Upload的时候提示Timed out waiting for packet header，明天再看吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://i207M.github.io/post/about/</id>
        <link href="https://i207M.github.io/post/about/">
        </link>
        <updated>2020-07-19T10:59:52.000Z</updated>
        <content type="html"><![CDATA[<p>i207Ｍ曾经是一位OIer，拥有NOI2019银牌。<br>
i207M毕业于SJZEZ。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://i207M.github.io/post/hello-gridea/</id>
        <link href="https://i207M.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>