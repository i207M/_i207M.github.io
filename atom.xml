<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://i207M.github.io</id>
    <title>i207M&apos;s Fantastic Blog</title>
    <updated>2020-08-13T08:41:57.578Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://i207M.github.io"/>
    <link rel="self" href="https://i207M.github.io/atom.xml"/>
    <subtitle>Lover - 世界都是我</subtitle>
    <logo>https://i207M.github.io/images/avatar.png</logo>
    <icon>https://i207M.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, i207M&apos;s Fantastic Blog</rights>
    <entry>
        <title type="html"><![CDATA[正则表达式-学习笔记]]></title>
        <id>https://i207M.github.io/post/zheng-ze-biao-da-shi-xue-xi-bi-ji/</id>
        <link href="https://i207M.github.io/post/zheng-ze-biao-da-shi-xue-xi-bi-ji/">
        </link>
        <updated>2020-08-13T06:06:34.000Z</updated>
        <content type="html"><![CDATA[<p>From <a href="https://www.luogu.com.cn/blog/0AND1STORY/zheng-ze-biao-da-shi">洛谷日报</a></p>
<p>正则表达式（Regular Expression, 简写为regex）</p>
<h3 id="选择">选择</h3>
<p><code>|</code>：选择（最低优先级）。</p>
<h3 id="数量限定">数量限定</h3>
<p><code>+</code>：前面的字符至少出现一次；</p>
<p><code>?</code>：最多出现一次；</p>
<p><code>*</code>：出现任意次（包括0次）。</p>
<h3 id="括号">括号</h3>
<p>定义范围和优先度。</p>
<h2 id="pcre表达式">PCRE表达式</h2>
<p><code>^</code>：匹配输入字符串的开始位置。</p>
<p><code>$</code>：匹配输入字符串的结束位置。</p>
<p><code>{n}</code>：匹配确定的n次。</p>
<p><code>{n,}</code>：至少匹配n次。</p>
<p><code>{n,m}</code>：最少n次最多m次。</p>
<p><code>?</code>：非贪心量化：当该字符在任何其他重复修饰符（<code>*,+,?</code>，<code>{n}</code>，<code>{n,}</code>，<code>{n,m}</code>）后面时，匹配模式是非贪婪的（默认为贪婪）。例如，对于字符串&quot;<code>oooo</code>&quot;，&quot;<code>o+?</code>&quot;将匹配单个&quot;<code>o</code>&quot;，而&quot;<code>o+</code>&quot;将匹配所有&quot;<code>o</code>&quot;。</p>
<p><code>.</code>：匹配除<code>\r,\n</code>之外任何单个字符。</p>
<p><code>(?:pattern)</code>：难以叙述...例如：<code>industr(?:y|ies)</code>等价于<code>industry|industries</code>。也就是说，如果pattern没匹配上，那么前面的字符也不匹配。</p>
<p><code>(?=pattern)</code>：正向肯定预查。<code>Windows(?=95|98|NT|2000)</code>能匹配<code>Windows2000</code>中的<code>Windows</code>，但不能匹配<code>Windows3.1</code>中的<code>Windows</code>。预查不消耗字符。</p>
<p><code>(?!pattern)</code>：正向否定预查。</p>
<p><code>(?&lt;=pattern)</code>：反向肯定预查。<code>(?&lt;=95|98|NT|2000)Windows</code>能匹配<code>2000Windows</code>中的<code>Windows</code>，但不能匹配<code>3.1Windows</code>中的<code>Windows</code>。</p>
<p><code>(?&lt;!pattern)</code>：反向否定预查。</p>
<p><code>[xyz]</code>：匹配所包含的任意一个字符。（<code>[^xyz]</code>反之）</p>
<p><code>[x-z]</code>：匹配范围内的任意一个字符。（<code>[^x-z]</code>反之）</p>
<p><code>\b</code>：匹配一个单词边界。</p>
<p><code>\B</code>：匹配一个非单词边界。</p>
<p><code>\d</code>：匹配一个数字。（<code>\D</code>反之）</p>
<p><code>\s</code>：匹配一个空白字符。</p>
<p><code>\w</code>：匹配任何<strong>单词字符</strong>(即<em>字母、数字、下划线</em>)。</p>
<h3 id="posix字符组">POSIX字符组</h3>
<p><code>[:alnum:]</code></p>
<p><code>[:alpha:]</code></p>
<p><code>[:ascii:]</code></p>
<p><code>[:lower:]</code></p>
<p><code>[:upper:]</code></p>
<h2 id="优先级">优先级</h2>
<table>
<thead>
<tr>
<th style="text-align:center">优先权</th>
<th style="text-align:center">符号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最高</td>
<td style="text-align:center"><code>\</code></td>
</tr>
<tr>
<td style="text-align:center">高</td>
<td style="text-align:center"><code>()</code>、<code>(?:)</code>、<code>(?=)</code>、<code>[]</code></td>
</tr>
<tr>
<td style="text-align:center">中</td>
<td style="text-align:center"><code>*</code>、<code>+</code>、<code>?</code>、<code>{n}</code>、<code>{n,}</code>、<code>{n,m}</code></td>
</tr>
<tr>
<td style="text-align:center">低</td>
<td style="text-align:center"><code>^</code>、<code>$</code>、中介字符</td>
</tr>
<tr>
<td style="text-align:center">次最低</td>
<td style="text-align:center">串接，即相邻字符连接在一起</td>
</tr>
<tr>
<td style="text-align:center">最低</td>
<td style="text-align:center"><code>|</code></td>
</tr>
</tbody>
</table>
<h1 id="python应用">Python应用</h1>
<p>使用<code>re</code>库。</p>
<p><code>re.match(r'^\d{3}\-\d{3,8}$', '010-12345')</code>，建议使用r前缀避免考虑Python的转义问题（正则的转义，如<code>\-</code>仍然要考虑）。<strong><code>re.match</code>尝试从起始位置匹配一个模式。</strong></p>
<p>匹配成功返回一个<code>Match</code>对象，否则返回<code>None</code>。</p>
<p><code>re.search()</code>扫描整个字符串并返回第一个成功的匹配。</p>
<p><code>findall()</code>返回一个list，内容是所有匹配的子串（str）。</p>
<p><code>Match</code>对象的方法：</p>
<ul>
<li><code>start()</code>返回匹配开始的位置</li>
<li><code>end()</code></li>
<li><code>span()</code>返回<code>(start(),end())</code></li>
</ul>
<h4 id="匹配邮件地址">匹配邮件地址</h4>
<p><code>re.match(r'^\w+(\w+|\.\w+)+@\w+(\w+|\.\w+)+$', addr)</code></p>
<h3 id="切分字符串">切分字符串</h3>
<p><code>'a b c'.split(' ')</code>无法识别连续的空格。</p>
<p><code>re.split(r'\s+','a b c')</code>可以。</p>
<h3 id="分组">分组</h3>
<p>用<code>()</code>表示要提取的分组。例如<code>^(\d{3})-(\d{3,8})$</code>定义了两个组。使用<code>group()</code>方法取出：</p>
<pre><code class="language-python">&gt;&gt;&gt; m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
&gt;&gt;&gt; m
&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;
&gt;&gt;&gt; m.group(0) # 原串
'010-12345'
&gt;&gt;&gt; m.group(1)
'010'
&gt;&gt;&gt; m.group(2)
'12345'
</code></pre>
<h4 id="命名分组">命名分组</h4>
<p><code>(?P&lt;name&gt;regex)</code>，调用：<code>matchobj.group(name)</code></p>
<h3 id="编译">编译</h3>
<p>每次使用正则表达式都需要编译，如果多次使用可以预编译：</p>
<pre><code class="language-python">import re
# 编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')

&gt;&gt;&gt; re_telephone.match('010-12345').groups()
('010', '12345')
</code></pre>
<h3 id="替换">替换</h3>
<p><code>re.sub(pattern,repl,string)</code></p>
<p><code>repl</code>是替换后的字符串，也可以是一个函数：这个函数传入的参数为<code>Match</code>对象。</p>
<p>假如文本有个单纯重复了 2 次，利用正则保留一个输出:</p>
<pre><code class="language-python">import re
x='this is is ok ok'
y= re.sub(r'(\w+)\s\1',r'\1',x)
print(y) # this is ok
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习笔记-网络编程]]></title>
        <id>https://i207M.github.io/post/python-wang-luo-bian-cheng/</id>
        <link href="https://i207M.github.io/post/python-wang-luo-bian-cheng/">
        </link>
        <updated>2020-08-12T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>学会urllib和requests之后，再来学学底层的TCP协议（UDP鸽了）。</p>
<h1 id="客户端">客户端</h1>
<pre><code class="language-python">import socket

s = socket.socket() # 创建socket
s.connect(('www.baidu.com', 80))

s.send(b'GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n')

buffer = []
while True:
    d = s.recv(1024) # 取出1024字节
    if d:
        buffer.append(d)
    else:
        break

s.close() # 关闭socket

data = b''.join(buffer)
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode())
with open('t.html', 'wb') as f: # 保存
    f.write(html)
</code></pre>
<p><code>socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>，其中<code>AF_INET</code>指定使用IPv4协议，<code>AF_INET6</code>表示IPv6。<code>SOCK_STREAM</code>指定使用面向流的TCP协议。如无特殊情况可以留空。</p>
<p>使用HTTPS：</p>
<pre><code class="language-python">import ssl

s = ssl.wrap_socket(socket.socket())
s.connect(('www.baidu.com', 443))
</code></pre>
<h1 id="服务端">服务端</h1>
<p>服务端需要打开特定端口监听。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口。但是服务器还需要同时相应多个客户端的请求，所以每个连接都需要一个新的进程或线程来处理。</p>
<p>简单的例子，接收客户端连接，把客户端发送的字符串加上<code>Hello</code>再发回去：</p>
<p><strong>服务端</strong>：</p>
<pre><code class="language-python">import socket
import threading
import time

s = socket.socket()
s.bind(('127.0.0.1', 6666)) # 绑定端口
s.listen(5) # 此socket最多同时与
print('Waiting for connection...')


def tcplink(sock, addr):
    print('Accept new connection from %s:%s' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024) # 读取
        time.sleep(1)
        if not data or data.decode() == 'exit':
            break
        sock.send((b'Hello, %s!' % data.decode()).encode())
    sock.close()
    print('Connection for %s:%s closed' % addr)


while True:
    sock, addr = s.accept()
    t = threading.Thread(target=tcplink, args=(sock, addr)) # 新建进程
    t.start()
</code></pre>
<p>客户端：</p>
<pre><code class="language-python">import socket
import random

s = socket.socket()
s.connect(('127.0.0.1', 6666))

print(s.recv(1024).decode())
for i in range(5):
    name = chr(random.randint(65, 90))
    s.send(name.encode())
    print(s.recv(1024).decode())
s.send(b'exit')
s.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习笔记-图形界面]]></title>
        <id>https://i207M.github.io/post/python-xue-xi-bi-ji-tu-xing-jie-mian/</id>
        <link href="https://i207M.github.io/post/python-xue-xi-bi-ji-tu-xing-jie-mian/">
        </link>
        <updated>2020-08-11T08:22:13.000Z</updated>
        <content type="html"><![CDATA[<p>python支持多种图形界面的第三方库，包括：Tk,Qt,GTK等。python自带的是支持Tk的Tkinter。</p>
<h1 id="turtle">turtle</h1>
<p>好可爱的绘图库...</p>
<pre><code class="language-python">width(5) # 设置笔刷宽度
pencolor('red') # 设置颜色
forward(200)
right(90)
</code></pre>
<h1 id="tkinter">Tkinter</h1>
<p>廖雪峰的博客讲的不清楚啊...</p>
<p>抄的代码：</p>
<pre><code class="language-python">from tkinter import *


class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

    def createWidgets(self):
        self.helloLable = Label(self, text='Hello, world!')
        self.helloLable.pack()
        self.quitButton = Button(self, text='Quit', command=self.quit)
        self.quitButton.pack()


app = Application()
app.master.title('Hello, world')
app.mainloop()

</code></pre>
<p>将来学<a href="https://www.cnblogs.com/shwee/p/9427975.html">这个</a>吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习笔记-爬虫探索]]></title>
        <id>https://i207M.github.io/post/python-pa-chong-tan-suo/</id>
        <link href="https://i207M.github.io/post/python-pa-chong-tan-suo/">
        </link>
        <updated>2020-08-09T01:41:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="百度翻译">百度翻译</h1>
<h2 id="模仿"><a href="https://www.jianshu.com/p/4c3e228940c8">模仿</a></h2>
<p>分析百度词典：</p>
<ol>
<li>打开F12，查看Network栏</li>
<li>尝试输入单词girl，发现每敲一个字母后面都有请求</li>
<li>请求地址是：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Ffanyi.baidu.com%2Fsug">https://fanyi.baidu.com/sug</a></li>
<li>请求方式：POST</li>
<li>利用NetWork-All-Hearders查看，发现Form data的值是kw:girl，所以字典的key名为kw。</li>
<li>查看返回内容格式，返回的是json格式内容，需要用到json包</li>
</ol>
<hr>
<p>啊啊啊这几天太摸了！！！</p>
<hr>
<pre><code class="language-python">from urllib import request, parse, error
import json

baseURL = 'https://fanyi.baidu.com/sug'

try:
    word = input('INPUT:')
    dat = parse.urlencode({&quot;kw&quot;: word}).encode()
    with request.urlopen(baseURL, data=dat) as f:
        # print('Status:', f.status, f.reason)
        ret = f.read().decode()
        ret = json.loads(ret)
        # print(ret['data'])
        ls = [a['k'] for a in ret['data']]
        if word in ls:
            print('%s: %s' % (word, ret['data'][0]['v']))
            print('Similar expressions:')
        else:
            print('NOT FOUND. Did you mean:')
        print(ls)
except error.URLError as e:
    print(e)
# 爽！

# Upd on 8.11
import requests
import json

BaseURL = 'https://fanyi.baidu.com/sug'

try:
    word = input('INPUT:')
    r = requests.post(BaseURL, data={'kw': word})
    r.raise_for_status()
    js = json.loads(r.text)
    print(js)
except requests.RequestException as e:
    print(e)

# requests更爽！
</code></pre>
<h2 id="百度翻译api">百度翻译API</h2>
<p>抓包发现返回的翻译内容来自https://fanyi.baidu.com/v2transapi?from=en&amp;to=zh</p>
<p>Let's try!</p>
<p>该死，竟然加密了...懒得搞了，看这个<a href="https://github.com/ZCY01/BaiduTranslate">接口</a>吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[录取后小记]]></title>
        <id>https://i207M.github.io/post/lu-qu-hou-xiao-ji/</id>
        <link href="https://i207M.github.io/post/lu-qu-hou-xiao-ji/">
        </link>
        <updated>2020-08-06T13:46:46.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[VS Code使用技巧]]></title>
        <id>https://i207M.github.io/post/vs-code-shi-yong-ji-qiao/</id>
        <link href="https://i207M.github.io/post/vs-code-shi-yong-ji-qiao/">
        </link>
        <updated>2020-08-04T11:13:42.000Z</updated>
        <content type="html"><![CDATA[<p><em>8.4：今天有点摸，干脆学学VS Code里有没有我还不知道的小技巧。</em></p>
<p><code>alt+shift+left/right</code>：Shrink/expand selection</p>
<p><code>F12</code>：跳转定义（按下<code>ctrl+p</code>后输入<code>@</code>可以浏览所有定义）</p>
<p><code>alt+F12</code>：速览2定义</p>
<p><code>F2</code>：重命名符号！！！</p>
<p><code>alt+left</code>：回到先前的位置</p>
<h3 id="重构">重构</h3>
<p>https://code.visualstudio.com/docs/editor/refactoring</p>
<p>https://code.visualstudio.com/docs/python/editing#_refactoring</p>
<p>很好用的功能。</p>
<p>可以批量重命名变量、将重复语句变成函数/变量。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python学习笔记]]></title>
        <id>https://i207M.github.io/post/python-xue-xi-bi-ji/</id>
        <link href="https://i207M.github.io/post/python-xue-xi-bi-ji/">
        </link>
        <updated>2020-07-31T09:25:07.000Z</updated>
        <content type="html"><![CDATA[<p>Learn from <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">this</a></p>
<h2 id="2020731">2020.7.31</h2>
<h3 id="容器初始化">容器初始化</h3>
<pre><code>list:[]
tuple:()
dict:{:}
set:{}
</code></pre>
<h3 id="函数参数">函数参数</h3>
<h4 id="位置参数">位置参数</h4>
<p>默认参数：默认参数必须指向不变对象！默认参数的值是在函数构建时被定义的。可以单独定义某个默认参数的值：</p>
<pre><code class="language-python">def enroll(a, b, c=1, d=2):
    print(a, b, c, d)

enroll(1, 2, d=5) # output: 1 2 1 5
</code></pre>
<h4 id="可变参数">可变参数</h4>
<p>可以传入一个<code>tuple</code>来解决</p>
<pre><code class="language-python">def calc(numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc((1,2,3)) # 此处要用双层括号
14
</code></pre>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

&gt;&gt;&gt; calc(1, 2)
5
&gt;&gt;&gt; calc()
0
&gt;&gt;&gt; nums = [1, 2, 3]
&gt;&gt;&gt; calc(*nums)
14
</code></pre>
<p><code>*</code>的作用是将tuple的内容拆成一个个参数然后传入。</p>
<h4 id="关键字参数">关键字参数</h4>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个<strong>tuple</strong>。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<strong>dict</strong>。</p>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
            
&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}
&gt;&gt;&gt; person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<h4 id="命名关键字参数">命名关键字参数</h4>
<p>限制关键字参数的名字。</p>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
    
&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<p>命名关键字参数必须传入参数名；命名关键字参数可以有缺省值。</p>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了。</p>
<h4 id="参数组合">参数组合</h4>
<p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p>
<h3 id="切片">切片</h3>
<p><code>s[L:R:D]</code>表示将s的<code>[L,R)</code>间距为D的片段切下来</p>
<p>特别的，<code>s[:2]</code> 表示切<code>s</code>的前两个元素；<code>s[-2:]</code>表示切<code>s</code>的后两个元素。</p>
<h3 id="迭代">迭代</h3>
<pre><code class="language-python">d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
for val in d.values():
    print(val)
for it in d.items():
    print(it) # tuple
</code></pre>
<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<pre><code class="language-python">for i, val in enumerate(['a', 'b', 'c']):
    print(i, val)
    
0 A
1 B
2 C

for x, y in [(1, 1), (2, 4), (3, 9)]:
	print(x, y)
</code></pre>
<h3 id="列表生成式">列表生成式</h3>
<p>感觉很好用！</p>
<pre><code class="language-python">L = list(range(1, 11))
L = [x * x for x in range(1, 11) if x % 2 == 0]
L = [m + n for m in ['a', 'b', 'c'] for n in ['x', 'y', 'z']]
</code></pre>
<h4 id="ifelsefor">if,else,for</h4>
<pre><code class="language-python">&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<h3 id="生成器">生成器</h3>
<p>简单的生成器相当于把list换成tuple。生成器只有next方式调出下一个，不能随机访问。可以用for遍历。</p>
<pre><code class="language-python">g = (x * x for x in range(10))
print(next(g))
for x in g:
    print(x, end=' ')

0
1 4 9 16 25 36 49 64 81

# 斐波那契数列生成器
def fib():
    a, b = 0, 1
    while True:
        yield b # ！！！
        a, b = b, a + b


f = fib()
for x in f:
    print(x)
    input()
</code></pre>
<p>变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p>generator函数也可以有返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中。</p>
<pre><code class="language-python">def triangles():
    A = []
    while True:
        for i in range(len(A) - 1, 0, -1):
            A[i] += A[i - 1]
        A.append(1)
        yield list(A)
</code></pre>
<p>以上是生成杨辉三角的生成器，值得注意的一点是，函数如果直接返回A，那么在函数里A的值改变的话，导出的A的值也会变。</p>
<p>改进版：</p>
<pre><code class="language-python">def triangles():
    A = [1]
    yield A
    while True:
        A = [1] + [A[i] + A[i + 1] for i in range(len(A) - 1)] + [1]
        yield A
</code></pre>
<p>为什么这样就可以返回A了呢，因为每经过一次赋值操作，A的地址都会重新分配。</p>
<h2 id="81">8.1</h2>
<h3 id="mapreduce">map&amp;reduce</h3>
<p>我们先看map。<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<pre><code class="language-python">def f(x):
	return x * x

&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>比方说对一个序列求和，就可以用<code>reduce</code>实现：</p>
<pre><code class="language-python">from functools import reduce
def add(x, y):
	return x + y

&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<p>利用此方法可以方便的实现str转int：</p>
<pre><code class="language-python">def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))

# lambda

def char2num(s):
    return DIGITS[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

# str2float

def str2float(s):
    def merge(x, y):
        return x * 10 + y

    def str2num(s):
        return reduce(merge, map(int, s))

    p = 0
    while p &lt; len(s) and s[p] != '.':
        p += 1
    if p == len(s):
        return str2num(s)
    return str2num(s[:p]) + str2num(s[p + 1:]) * 0.1**(len(s) - p - 1)

# 写的还是太长，等学会lambda和str的函数再简化吧
</code></pre>
<h3 id="filter">filter</h3>
<p>接收一个函数和一个序列，返回一个Iterator，只保留True的元素。</p>
<pre><code class="language-python">def is_palindrome(n):
    s = str(n)
    return s == s[::-1]
</code></pre>
<p>筛回文好简单...</p>
<h3 id="sorted">sorted</h3>
<p>我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序，相当于把所有元素都应用key之后再排序：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
['about', 'bob', 'Credit', 'Zoo']
</code></pre>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h3 id="闭包">闭包</h3>
<p>大杀器。类似于C++中的lamba.</p>
<p>返回一个函数，这个函数会同时包含它所需要的变量。</p>
<p>需要注意的问题：</p>
<p>返回的函数没有立即执行，而是等到调用才执行。 <strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<h4 id="创建计数器">创建计数器</h4>
<p>这道题很妙啊。</p>
<pre><code class="language-python">def createCounter():
    n = 0

    def counter():
        nonlocal n # 声明这是外层的变量
        n += 1
        return n

    return counter

def createCounter():
    n = [0]

    def counter():
        n[0] += 1 # 为什么这里可以修改？因为n这个变量实际上是指向一片内存地址！
        return n[0]

    return counter
</code></pre>
<h3 id="globalnonlocal">global&amp;nonlocal</h3>
<p>global用于修改全局变量；</p>
<p>nonlocal用于在函数或其他作用域中使用外层(非全局)变量。</p>
<h3 id="匿名函数">匿名函数</h3>
<p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数，冒号后面的表达式是返回值。</p>
<h3 id="装饰器">装饰器</h3>
<p>函数对象有一个<code>__name__</code>属性，可以拿到函数的名字：</p>
<pre><code class="language-python">&gt;&gt;&gt; f=now
&gt;&gt;&gt; now.__name__
'now'
&gt;&gt;&gt; f.__name__
'now'
</code></pre>
<p>假设我们要在<code>now</code>函数调用前后自动打印日志，但又不希望修改<code>now()</code>函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”。</p>
<p>本质上，decorator就是一个返回函数的高阶函数，可以定义如下：</p>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>我们可以借助Python的@语法，把decorator置于函数的定义处：</p>
<pre><code class="language-python">@log
def now():
    pass
</code></pre>
<p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志。</p>
<p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p>
<pre><code class="language-python">now = log(now)
</code></pre>
<p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。</p>
<p>decorater本身也可以传入参数：</p>
<p>比如，要自定义log的文本：</p>
<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>这个3层嵌套的decorator用法如下：</p>
<pre><code class="language-python">@log('execute')
def now():
    pass
</code></pre>
<p>但是，这样装饰之后的 函数，它的<code>__name__</code>已经不是原来的函数了。Python内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<pre><code class="language-python">import functools

def log(func):
    @functools.wraps(func) # !!!
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：</p>
<pre><code class="language-python">def metric(fn):
    @functools.wraps(fn)
    def warpper(*args, **kw):
        s = time.time()
        r = fn(*args, **kw)
        e = time.time()
        print('%s run in %.2f ms' % (fn.__name__, e - s))
        return r

    return warpper
</code></pre>
<h3 id="偏函数">偏函数</h3>
<pre><code class="language-python">int2 = functools.partial(int, base=2)
</code></pre>
<p>固定函数的参数。</p>
<h2 id="82">8.2</h2>
<h3 id="模块">模块</h3>
<pre><code class="language-python">'A module'  # 任何模块代码的第一个字符串都被视为模块的文档注释，可以用__doc__调用

__author__ = 'i207M' # 标准模板

import sys


def run():
    print(sys.argv) # sys模块定义了sys.argv，本质是list，储存了调用这个py文件的参数


if __name__ == '__main__': # 当且仅当它是独立运行而不是被import进别的py时，此判断为True
    run()
</code></pre>
<p>运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；</p>
<p>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael']</code>。</p>
<h4 id="作用域">作用域</h4>
<p>正常函数的命名是公开的。</p>
<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，如<code>__author__</code>，<code>__name__</code>，<code>__doc__</code>。</p>
<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的，不应该被直接引用。不应该，不是不能。</p>
<h3 id="面向对象oop">面向对象OOP</h3>
<p><code>__init__</code>方法相当于构造函数。注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身。</p>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，这样在外部就真的无法访问。但是在外部定义class的<code>__</code>开头的变量是可以被访问的。</p>
<p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>这就是著名的**开闭原则 **：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p><em>“鸭子类型”：它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</em></p>
<p><code>print</code>一个class，实质会调用<code>__str__()</code>函数，打印此函数的返回值。直接在控制台输入变量，打印的实例是调用<code>__repr__()</code>。</p>
<h4 id="定制类">定制类</h4>
<p>定义了<code>__iter__(),__next__()</code>，就可以被用于<code>for ... in</code>循环：</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self._a, self._b = 0, 1

    def __iter__(self):
        return self

    def __next__(self):
        self._a, self._b = self._b, self._a + self._b
        if self._a &gt; 1000:
            raise StopIteration()
        return self._a
</code></pre>
<p>实现<code>__getitem__()</code>方法，可以按下标访问任意一项。</p>
<p>当调用不存在的属性时，Python解释器会试图调用<code>__getattr__(self, 'name')</code>来尝试获得属性。</p>
<p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p>
<pre><code class="language-python">class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
</code></pre>
<p>试试：</p>
<pre><code class="language-python">&gt;&gt;&gt; Chain().status.user.timeline.list
'/status/user/timeline/list'
</code></pre>
<p>Niubi</p>
<p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。</p>
<pre><code class="language-python">class Chain(object):
    def __init__(self, path=''):
        self.path = path

    def __getattr__(self, attr):
        return Chain(&quot;%s/%s&quot; % (self.path, attr))

    def __call__(self, *args):
        _self = self
        for i in args:
            _self = Chain(&quot;%s/%s&quot; % (_self.path, i))
        return _self

    def __str__(self):
        return self.path

    __repr__ = __str__


&gt;&gt;&gt; print(Chain().a(&quot;hello&quot;, &quot;good&quot;).b)
/a/hello/good/b
</code></pre>
<h4 id="type">type</h4>
<p>type返回类型，是严格的类型，同一个父类下的子类互不相同。</p>
<p>使用<code>instance()</code>函数可以判断继承类型。</p>
<h3 id="类和实例">类和实例</h3>
<p>可以定义类属性和实例属性，实例属性优先于类属性。</p>
<p>实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>
<p>配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态。</p>
<p>为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<pre><code class="language-python">class Student(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Student.count += 1 # 方便！
</code></pre>
<h4 id="给实例绑定一个方法">给实例绑定一个方法</h4>
<pre><code class="language-python">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
&gt;&gt;&gt; from types import MethodType
&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法，只有s能调用

&gt;&gt;&gt; def set_score(self, score):
...     self.score = score
...
&gt;&gt;&gt; Student.set_score = set_score # 所有实例都可以调用
</code></pre>
<p>Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
</code></pre>
<p>对子类不起作用，除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<p>但是当父类无<code>__slots__</code>，而子类有，则无效。</p>
<h3 id="property">@property</h3>
<p>实现类的时候，我们常常需要提供各种借口，但是为每个接口都写一个函数有些麻烦，使用也不方便，我们可以用<code>@property</code>，使得可以直接调用变量，用等号修改，且进行范围检查。</p>
<pre><code class="language-python">class Student(object):
    @property
    def score(self):
        return self.__score

    @score.setter
    def score(self, val):
        if 0 &lt;= val and val &lt;= 100:
            self.__score = val
        else:
            raise ValueError('Score Error')
</code></pre>
<p><code>@property</code>后定义的函数作为此名变量的getter方法；此时，<code>@property</code>本身又创造了另一个修饰器<code>@score.setter</code>，实现setter方法，如果没有setter方法，则变量为只读。</p>
<h3 id="多重继承">多重继承</h3>
<p>RT：</p>
<pre><code class="language-python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>如果方法重复怎么办？优先保留顺序靠前的。</p>
<h3 id="枚举类">枚举类</h3>
<p>继承自Enum。<code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p>
<h3 id="元类">元类</h3>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072">太 妙 了！豁然开朗！</a>（用到时再复习吧）</p>
<p><strong><a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html">super()</a></strong></p>
<h2 id="83">8.3</h2>
<h3 id="错误处理">错误处理</h3>
<p>感觉这个挺重要的。</p>
<pre><code class="language-python">try:
    pass
expect ... as ...:
    pass
</code></pre>
<p>出错时，直接跳转到except语句块。错误也是class，继承自<code>BaseException</code>。</p>
<p>如果错误没有被捕获，会一直往上抛，最后被Python解释器捕获，打印错误信息并退出。这就是<strong>调用栈</strong>。</p>
<p>Python内置的<code>logging</code>模块可以记录错误信息。</p>
<pre><code class="language-python">try:
    main()
except Exception as e:
    logging.exception(e)
</code></pre>
<p>这样程序可以继续运行，并且错误被记录。</p>
<p><code>except</code>语句内可以继续<code>raise</code>，抛给上一层。</p>
<h3 id="调试">调试</h3>
<p><code>assert</code>+VS Code</p>
<h3 id="文件读写">文件读写</h3>
<p>使用<code>f=open(file,'r'/'rb'/'w'/'a'[,encoding=])</code>，退出程序前记得<code>f.close()</code>。</p>
<p>方便的方法是使用<code>with</code>语句：</p>
<pre><code class="language-python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>建议使用<code>with</code>语句，以防忘记<code>close</code>，如果不能直接使用<code>with</code>语句，可以</p>
<h4 id="stringiobytesio">StringIO&amp;BytesIO</h4>
<p>在内存中读写str。像文件一样写入即可。<code>from io import StringIO</code></p>
<h4 id="os模块">os模块</h4>
<pre><code class="language-python">os.path.abspath('')
os.path.join('','') # 拼接路径
os.mkdir('')
os.rmdir('')
os.path.split('') # 返回list，将路径拆为两部分，后一部分是文件（夹）名
os.path.splittext('') # 返回文件扩展名
os.rename('','')
os.remove('')
os.listdir('') # 文件夹+文件
os.path.isdir('')
</code></pre>
<p><code>copyfile()</code>在<code>shutil</code>模块。</p>
<p><code>os.walk('')</code>返回的是一个三元组(root,dirs,files)。</p>
<ul>
<li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li>
<li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li>
<li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li>
</ul>
<pre><code class="language-python">for root, dirs, files in os.walk('.'):
    for name in files:
        print(os.path.join(root, name))

def mywalk(path):
    for name in os.listdir(path):
        ful = os.path.join(path, name)
        if os.path.isdir(name):
            try:
                mywalk(ful)
            except Exception as e:
                print(e)
        else:
            print(ful)
</code></pre>
<h3 id="序列化">序列化</h3>
<p>先鸽了。大致用途是将Python对象变成JSON。</p>
<h3 id="常用内建模块">常用内建模块</h3>
<pre><code class="language-python">from datetime import datetime

now = datetime.now() # 是一个class
t = now.timestamp() # 返回从1970年开始的秒数，浮点数
datetime.fromtimestamp(t) # 本地时区

day = datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S') # 注意，转换后无时区信息
print(now.strftime('%a, %b %d %H:%M'))

def to_timestamp(dt_str, tz_str):
    tim = datetime.strptime(dt_str, '%Y-%m-%d %H:%M:%S')
    sq = re.findall(r'UTC(.*):00', tz_str)
    sq = int(sq[0])
    tim = tim.replace(tzinfo=timezone(timedelta(hours=sq)))
    return tim.timestamp()


t1 = to_timestamp('2015-6-1 08:10:30', 'UTC+7:00')
assert t1 == 1433121030.0
</code></pre>
<p>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</p>
<h4 id="collections">collections</h4>
<p><code>namedtuple('NAME',['args'])</code></p>
<p><code>deque</code></p>
<p><code>defaultdict(function)</code>有默认值的<code>dict</code></p>
<h4 id="hashlib">hashlib</h4>
<pre><code class="language-python">import hashlib

md5 = hashlib.md5('original')
md5.update('Hello, '.encode('utf-8')) # 必须encode
md5.update('World'.encode('utf-8'))
print(md5.hexdigest())
# 同理可用sha1

import hmac
h=hmac.new(key, message, digestmode='MD5')
</code></pre>
<h4 id="itertools">itertools</h4>
<pre><code class="language-python">&gt;&gt;&gt; for c in itertools.chain('ABC', 'XYZ'):
...     print(c)
# 迭代效果：'A' 'B' 'C' 'X' 'Y' 'Z'
</code></pre>
<h2 id="84">8.4</h2>
<p>昨天属实有点摸鱼。今天把<code>urllib</code>这些事学了。</p>
<p>强基快要出结果了.jpg</p>
<p>学这个之前要先把JSON学了。</p>
<h3 id="json">JSON</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/08/04/HPh7R5XcgVzAMpn.png" alt="image-20200804083520132" loading="lazy"></figure>
<p>使用内置的<code>json</code>模块。</p>
<p><code>json.dumps(arg)</code>返回<code>str</code>，内容是标准的JSON。<code>dump(arg,file)</code>可以直接把结果写入文件流中。</p>
<p>反序列化使用<code>loads()/load()</code>。</p>
<p>如果是自定义的Class如何序列化？</p>
<p>可选参数<code>default</code>把任意一个对象变成一个可序列为JSON的对象。</p>
<pre><code class="language-python">def student2dict(std):
    return dict(
        name=std.name,
        age=std.age,
        score=std.score,
    )
</code></pre>
<p>有一个Trick方法：</p>
<pre><code class="language-python">json.dumps(t, default=lambda obj: obj.__dict__)
</code></pre>
<p>同理可以反序列化。</p>
<h3 id="urllib">urllib</h3>
<p>基本上实现GET和POST就够了。</p>
<h4 id="get">GET</h4>
<p><code>request</code>模块可以发送一个GET到指定的页面。</p>
<pre><code class="language-python">from urllib import request

with request.urlopen('https://yesno.wtf/api') as f:
    data = f.read()
    print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        print('%s: %s' % (k, v))
    data = data.decode('utf-8')
    print('Data:', data)
    js = json.loads(data)
    print(js)
    for it in js.items():
        print('%s: %s' % it)
</code></pre>
<p>挺简单易懂的。如果使用<code>f.getheader(str)</code>，可以返回某个header.</p>
<p><code>urlopen</code>函数除了直接传入网址，还可以传入<code>Request</code>类，实现自定义header，从而自定义UA等功能。</p>
<pre><code class="language-python">req = request.Request('http://www.douban.com/')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
</code></pre>
<h4 id="post">POST</h4>
<p>只需要把参数以bytes形式传入。可以借助<code>parse.urlencode</code>.</p>
<p>模拟微博登录：</p>
<pre><code class="language-python">from urllib import request, parse

print('Login Weibo...')
email = input('Email:')
pwd = input('Password:')
login_data = parse.urlencode(
    [
        ('username', email), ('password', pwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''),
        ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')
    ]
)

req = request.Request('https://passport.weibo.cn/sso/login')
req.add_header('Origin', 'https://passport.weibo.cn')
req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')
req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')

with request.urlopen(req, data=login_data.encode('utf-8')) as f:
    print('Status:', f.status, f.reason)
    for it in f.getheaders():
        print('%s: %s' % it)
    print('Data:', f.read().decode('utf-8'))
</code></pre>
<h4 id="handler">Handler</h4>
<p>默认使用的代理是系统设置的，如果要更改，感觉urllib提供的实现很复杂，之后学习requsets或urllib2.</p>
<pre><code class="language-python"># urllib
proxy_handler = request.ProxyHandler({'http': 'http://127.0.0.1:2334', 'https': 'https://127.0.0.1:2334'})
proxy_auth_handler = request.ProxyBasicAuthHandler()
opener = request.build_opener(proxy_handler, proxy_auth_handler)
with opener.open('https://www.google.com/') as f:
    print('Status:', f.status, f.reason) # 200 OK
</code></pre>
<h2 id="810">8.10</h2>
<p><code>HTMLParser</code>：先鸽了。</p>
<h3 id="pil">PIL</h3>
<p>Python Imaging Library</p>
<pre><code class="language-python">from PIL import Image

im = Image.open('t.png')
w, h = im.size
im.thumbnail((w // 4, h // 4)) # 缩放
im.save('tt.jpg', 'jpeg')

im2 = im.filter(ImageFilter.BLUR) # 模糊
</code></pre>
<h4 id="生成验证码">生成验证码</h4>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random


def rndChar():
    return chr(random.randint(65, 90))


def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))


def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))


h = 60
w = h * 4

im = Image.new('RGB', (w, h), (255, 255, 255)) # 创建。Modes除了RGB还有'1'(1-bit,black and white),'L'(8-bit,black and white)

font = ImageFont.truetype('arial.ttf', 36) # 字体
draw = ImageDraw.Draw(im)
for x in range(w):
    for y in range(h):
        draw.point((x, y), fill=rndColor()) # 画背景

for t in range(4):
    draw.text((60 * t + 10, random.randint(1, 27)), rndChar(), font=font, fill=rndColor2()) # 写字母

im = im.filter(ImageFilter.BLUR)
im.save('code.jpg', 'jpeg')
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/08/10/24dZyRCYlbG1POB.jpg" alt="" loading="lazy"></figure>
<p>加强过后（加入了字符旋转）：</p>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont, ImageFilter
import random


def rndChar():
    return chr(random.randint(65, 90))


def rndColor():
    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))


def rndColor2():
    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))


h = 60
w = h * 4

im = Image.new('RGB', (w, h), (255, 255, 255))

font = ImageFont.truetype('arial.ttf', 40)
dr = ImageDraw.Draw(im)
for x in range(w):
    for y in range(h):
        dr.point((x, y), fill=rndColor())
for t in range(4):
    text_layer = Image.new('RGBA', (40, 40)) # 注意是RGBA，A表示透明度
    text_draw = ImageDraw.Draw(text_layer)
    text_draw.text((0, 0), rndChar(), font=font, fill=(*rndColor2(), 255))
    text_layer = text_layer.rotate(random.randint(0, 360)) # 旋转
    im.paste(text_layer, (60 * t, random.randint(0, 20)), text_layer) # 粘贴

im = im.filter(ImageFilter.BLUR)
im.save('code.jpg', 'jpeg')
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/08/10/o1c93qCtTzPfi4g.jpg" alt="" loading="lazy"></figure>
<p>爽！PythonNB！</p>
<h3 id="requests">requests</h3>
<p>比urllib更强悍。</p>
<pre><code class="language-python">r = requests.get('URL')
r.status_code
r.text # 内容（自动检测编码）
r.content # bytes对象
</code></pre>
<p>对于带参数的URL，传入dict作为<code>params</code>参数。</p>
<p><code>headers</code>参数可以传入dict。</p>
<p><em>另外一提，使用http访问百度搜索不需要UA，使用https就必须UA。</em></p>
<p>要发送POST，只需要把方法变成<code>post()</code>，然后用<code>data</code>参数作为POST请求的数据。默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON，可以传入json参数。</p>
<p><a href="https://blog.csdn.net/xiao__jia__jia/article/details/79357274">四种常见的 POST 提交数据方式</a></p>
<p><em>重写百度翻译爬虫ing</em></p>
<p>上传文件可以使用<code>files</code>参数，读取文件时，必须使用<code>'rb'</code>模式，这样获取的<code>bytes</code>长度才是文件的长度。</p>
<pre><code class="language-python">upfile = {'file': open('name','rb')}
r = requests.post(url, files=upfile)
</code></pre>
<p>requests对cookie做了处理，使我们不必解析cookie就可以直接获取指定的cookie。</p>
<pre><code class="language-python">print(r.cookies['token'])
</code></pre>
<p>要传入cookie，只需将dict传入<code>cookies</code>参数。</p>
<p>要指定超时，传入以秒为单位的<code>timeout</code>参数。</p>
<h3 id="chardet">chardet</h3>
<p>对于未知编码的<code>bytes</code>，转换成<code>str</code>需要“猜测”编码，<code>chardet</code>这个第三方库通过收集编码的特征字符，有很大概率猜对。</p>
<pre><code class="language-python">&gt;&gt;&gt; data = '离离原上草，一岁一枯荣'.encode('gbk')
&gt;&gt;&gt; chardet.detect(data)
{'encoding': 'GB2312', 'confidence': 0.7407407407407407, 'language': 'Chinese'}
</code></pre>
<p><code>confidence</code>是概率。</p>
<h3 id="psutil">psutil</h3>
<p>psutil = process and system utilities</p>
<p>获取系统信息，先鸽了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[物联网开发笔记]]></title>
        <id>https://i207M.github.io/post/iot-kai-fa-ru-men/</id>
        <link href="https://i207M.github.io/post/iot-kai-fa-ru-men/">
        </link>
        <updated>2020-07-30T14:28:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="2020730">2020.7.30</h2>
<p>THU面试结束，开始心仪已久的IoT开发尝试。首先使用的是ESP-8266系列的ESP-01芯片。<br>
上午主要把驱动和Arduino IDE鼓捣好了，感谢我爸事先的开荒。<br>
后来花了好长时间尝试点灯（就是运行Blink实例），怎么样都不能成功，后来发现ESP-01S才有灯，我手里这个没有...<br>
后来又花了好长时间尝试Advanced Webserver这个示例，同样是一直无解，甚至都以为自己不小心刷坏了WiFi模块...直到把这个问题给小黄鸭（家父）说了一下，然后猛然意识到，SSID和password应该填自己家已有的WiFi...睿智了睿智了，然后就成功的连上了WiFi并作为服务器连接到了我的小板子。<br>
晚上开始鼓捣PlatformIO，但是Upload的时候提示Timed out waiting for packet header，明天再看吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://i207M.github.io/post/about/</id>
        <link href="https://i207M.github.io/post/about/">
        </link>
        <updated>2020-07-19T10:59:52.000Z</updated>
        <content type="html"><![CDATA[<p>i207Ｍ曾经是一位OIer，拥有NOI2019银牌。<br>
i207M毕业于SJZEZ。<br>
i207M进入清华大学-信息与计算科学系（强基计划）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://i207M.github.io/post/hello-gridea/</id>
        <link href="https://i207M.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>